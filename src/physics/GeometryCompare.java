package physics;import physics.Geometry.VectPair;import physics.Geometry.DoublePair;/**************************************************************************** * Copyright (C) 2001 by the Massachusetts Institute of Technology, *                       Cambridge, Massachusetts. * ***************************************************************************//** 判断两个对象间的行为是否一致*/public class GeometryCompare implements GeometryInterface{  public static double TOLERANCE = 1E-12;  public GeometryCompare(GeometryInterface g1, GeometryInterface g2)  {    if (g1 == null) throw new IllegalArgumentException("g1 null");    if (g2 == null) throw new IllegalArgumentException("g2 null");    this.g1 = g1;    this.g2 = g2;  }  private final GeometryInterface g1, g2;  private static interface StringThunk  {    public String string();  }  private static final StringThunk NONE = new StringThunk() {      public String string() { return ""; }    };  private class AddStringThunk    implements StringThunk  {    public AddStringThunk(String before, StringThunk body, String after)    {      this.before = before;      this.body = body;      this.after = after;    }    private final String before;    private final StringThunk body;    private final String after;    public String string()    {      return before + body.string() + after;    }  }  // specification taken from GeometryInferface; not strengthened  public DoublePair quadraticSolution(double a, double b, double c) {    return compareAndReturn(NONE, g1.quadraticSolution(a, b, c),			    g2.quadraticSolution(a, b, c));  }  // specification taken from GeometryInferface; not strengthened  public double minQuadraticSolution(double a, double b, double c) {    return compareAndReturn(NONE, g1.minQuadraticSolution(a, b, c),			    g2.minQuadraticSolution(a, b, c));  }  // specification taken from GeometryInferface; not strengthened  public Vect perpendicularPoint(LineSegment line, Vect point) {    return compareAndReturn(NONE, g1.perpendicularPoint(line, point),			    g2.perpendicularPoint(line, point));  }  // specification taken from GeometryInferface; not strengthened  public Vect perpendicularPointWholeLine(LineSegment line, Vect point) {    return compareAndReturn(NONE, g1.perpendicularPointWholeLine(line, point),			    g2.perpendicularPointWholeLine(line, point));  }  // specification taken from GeometryInferface; not strengthened  public Vect applyReflectionCoeff(Vect incidentVect, Vect reflectedVect, double rCoeff) {    return compareAndReturn(NONE, g1.applyReflectionCoeff(incidentVect, reflectedVect, rCoeff),			    g2.applyReflectionCoeff(incidentVect, reflectedVect, rCoeff));  }  // specification taken from GeometryInferface; not strengthened  public double timeUntilWallCollision(LineSegment line, Circle ball, Vect velocity) {    return compareAndReturn(NONE, g1.timeUntilWallCollision(line, ball, velocity),			    g2.timeUntilWallCollision(line, ball, velocity));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectWall(LineSegment line, Vect velocity, double reflectionCoeff) {    return compareAndReturn(NONE, g1.reflectWall(line, velocity, reflectionCoeff),			    g2.reflectWall(line, velocity, reflectionCoeff));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectWall(LineSegment line, Vect velocity) {    return compareAndReturn(NONE, g1.reflectWall(line, velocity),			    g2.reflectWall(line, velocity));  }  // specification taken from GeometryInferface; not strengthened  public double distanceSquared(Vect v1, Vect v2) {    return compareAndReturn(NONE, g1.distanceSquared(v1, v2),			    g2.distanceSquared(v1, v2));  }  // specification taken from GeometryInferface; not strengthened  public double distanceSquared(double x1, double y1, double x2, double y2) {    return compareAndReturn(NONE, g1.distanceSquared(x1, y1, x2, y2),			    g2.distanceSquared(x1, y1, x2, y2));  }  // specification taken from GeometryInferface; not strengthened  public double timeUntilCircleCollision(Circle circle, Circle ball, Vect velocity) {    return compareAndReturn(NONE, g1.timeUntilCircleCollision(circle, ball, velocity),			    g2.timeUntilCircleCollision(circle, ball, velocity));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectCircle(Vect circle, Vect ball, Vect velocity, double reflectionCoeff) {    return compareAndReturn(NONE, g1.reflectCircle(circle, ball, velocity, reflectionCoeff),			    g2.reflectCircle(circle, ball, velocity, reflectionCoeff));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectCircle(Vect circle, Vect ball, Vect velocity) {    return compareAndReturn(NONE, g1.reflectCircle(circle, ball, velocity),			    g2.reflectCircle(circle, ball, velocity));  }  // specification taken from GeometryInferface; not strengthened  public Vect rotateAround(Vect point, Vect cor, Angle a) {    return compareAndReturn(NONE, g1.rotateAround(point, cor, a),			    g2.rotateAround(point, cor, a));  }  // specification taken from GeometryInferface; not strengthened  public LineSegment rotateAround(LineSegment line, Vect cor, Angle a) {    return compareAndReturn(NONE, g1.rotateAround(line, cor, a),			    g2.rotateAround(line, cor, a));  }  // specification taken from GeometryInferface; not strengthened  public Circle rotateAround(Circle circle, Vect cor, Angle a) {    return compareAndReturn(NONE, g1.rotateAround(circle, cor, a),			    g2.rotateAround(circle, cor, a));  }  // specification taken from GeometryInferface; not strengthened  public DoublePair timeUntilCircleCollision(Circle circle, Vect point, Vect velocity) {    return compareAndReturn(NONE, g1.timeUntilCircleCollision(circle, point, velocity),			    g2.timeUntilCircleCollision(circle, point, velocity));  }  // specification taken from GeometryInferface; not strengthened  public double timeUntilRotatingWallCollision(final LineSegment line,					       final Vect center,					       final double angularVelocity,					       final Circle ball,					       final Vect velocity)  {    StringThunk message = new StringThunk() {	public String string() {	  return	    "timeUntilRotatingWallCollision(" +	    line +	    " " +	    center +	    " " +	    angularVelocity +	    " " +	    ball +	    " " + 	    velocity + 	    ")";	}      };    return compareAndReturn(message,			    g1.timeUntilRotatingWallCollision(line, center, angularVelocity, ball, velocity),			    g2.timeUntilRotatingWallCollision(line, center, angularVelocity, ball, velocity));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity) {    return compareAndReturn(NONE, g1.reflectRotatingWall(line, center, angularVelocity, ball, velocity),			    g2.reflectRotatingWall(line, center, angularVelocity, ball, velocity));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity, double reflectionCoeff) {    return compareAndReturn(NONE, g1.reflectRotatingWall(line, center, angularVelocity, ball, velocity, reflectionCoeff),			    g2.reflectRotatingWall(line, center, angularVelocity, ball, velocity, reflectionCoeff));  }  // specification taken from GeometryInferface; not strengthened  public double timeUntilRotatingCircleCollision(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity) {    return compareAndReturn(NONE, g1.timeUntilRotatingCircleCollision(circle, center, angularVelocity, ball, velocity),			    g2.timeUntilRotatingCircleCollision(circle, center, angularVelocity, ball, velocity));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectRotatingCircle(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity) {    return compareAndReturn(NONE, g1.reflectRotatingCircle(circle, center, angularVelocity, ball, velocity),			    g2.reflectRotatingCircle(circle, center, angularVelocity, ball, velocity));  }  // specification taken from GeometryInferface; not strengthened  public Vect reflectRotatingCircle(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity, double reflectionCoeff) {    return compareAndReturn(NONE, g1.reflectRotatingCircle(circle, center, angularVelocity, ball, velocity, reflectionCoeff),			    g2.reflectRotatingCircle(circle, center, angularVelocity, ball, velocity, reflectionCoeff));  }  // specification taken from GeometryInferface; not strengthened  public double timeUntilBallBallCollision(Circle ball1, Vect vel1, Circle ball2, Vect vel2) {    return compareAndReturn(NONE, g1.timeUntilBallBallCollision(ball1, vel1, ball2, vel2),			    g2.timeUntilBallBallCollision(ball1, vel1, ball2, vel2));  }  // specification taken from GeometryInferface; not strengthened  public VectPair reflectBalls(Vect center1, double mass1, Vect velocity1, Vect center2, double mass2, Vect velocity2) {    return compareAndReturn(NONE, g1.reflectBalls(center1, mass1, velocity1, center2, mass2, velocity2),			    g2.reflectBalls(center1, mass1, velocity1, center2, mass2, velocity2));  }  /** 抛出错误信息*/  private static void error(StringThunk message, double a, double b)  {    throw new RuntimeException("Assertion error: " + a + " != " + b + "; diff = " + (a - b) + "\n" +			       message.string());  }  /** 抛出警告信息*/  private static void assertEquals(StringThunk message, double a, double b)  {    if (Double.isNaN(a)) {      if (Double.isNaN(b)) {	return;      } else {	error(message, a, b);      }    }    if (Double.isInfinite(a)) {      if (Double.isInfinite(b)) {	return;      } else {	error(message, a, b);      }    }    double diff = Math.abs(a - b);    if (diff < TOLERANCE) {      return;    } else {      error(message, a, b);    }  }  /**当a和b的差异在限度之内返回a*/  private static double compareAndReturn(StringThunk message, double a, double b)  {    assertEquals(message, a, b);    return a;  }  private static DoublePair compareAndReturn(StringThunk message, DoublePair a, DoublePair b)  {    assertEquals(message, a.d1, b.d1);    assertEquals(message, a.d2, b.d2);    return a;  }  private static Vect compareAndReturn(StringThunk message, Vect a, Vect b)  {    assertEquals(message, a.x(), b.x());    assertEquals(message, a.x(), b.x());    return a;  }  private static VectPair compareAndReturn(StringThunk message, VectPair a, VectPair b)  {    compareAndReturn(message, a.v1, b.v1);    compareAndReturn(message, a.v2, b.v2);    return a;  }  private static Circle compareAndReturn(StringThunk message, Circle a, Circle b)  {    compareAndReturn(message, a.getCenter(), b.getCenter());    compareAndReturn(message, a.getRadius(), b.getRadius());    return a;  }  private static LineSegment compareAndReturn(StringThunk message, LineSegment a, LineSegment b)  {    compareAndReturn(message, a.p1(), b.p1());    compareAndReturn(message, a.p2(), b.p2());    return a;  }}