package physics;import java.util.Collections;import java.util.List;import java.util.LinkedList;import java.util.Iterator;import java.util.ListIterator;import java.io.Serializable;/**************************************************************************** * Copyright (C) 1999-2001 by the Massachusetts Institute of Technology, *                       Cambridge, Massachusetts. ***************************************************************************//**.一系列区间范围的抽象*/public class IntervalList implements Serializable{    /** 一个间隔是一个连续变化的数字范围 */  public static class Interval implements Comparable, Serializable  {        public final double start;    public final double end;    /** 构造函数*/    public Interval(double start, double end) {      if (Double.isNaN(start) || Double.isNaN(end)) {	throw new IllegalArgumentException();      }      if (end < start) {	System.out.println("start = " + start);	System.out.println("end   = " + end);	throw new IllegalArgumentException();      }      this.start = start;      this.end = end;    }    /** 获取这个间隔区间的下边界*/    public double start() {      return start;    }     /** 获取这个间隔区间的上边界*/    public double end() {      return end;    }    /** 判断两个间隔区间是否有重叠*/    private boolean overlaps(Interval i) {      if (this.start <= i.start) {	if (i.start > this.end) {	  return false;	} else {	  return true;	}      } else {	return i.overlaps(this);      }    }    /** 合并两个间隔区间*/    private Interval merge(Interval i) {      if (overlaps(i)) {	if (this.start <= i.start) {	  return new Interval(this.start, (i.end>this.end) ? i.end : this.end);	} else {	  return i.merge(this);	}      } else {	throw new IllegalArgumentException();      }    }    /** 构造一个长度一定的间隔区间*/    private Interval restrictLength(double length) {      if (!Double.isInfinite(start) && !Double.isInfinite(end) &&	  (end - start > length)) {	return new Interval(start, start + length);      } else if (!Double.isInfinite(start) && Double.isInfinite(end)) {	return new Interval(start, start + length);      } else {	return this;      }    }    /** 获取两个间隔区间相交的部分*/    private Interval restrictTo(Interval i) {      if (!overlaps(i)) {	throw new IllegalArgumentException();      }      return new Interval(start > i.start ? start : i.start,			  end   < i.end   ? end   : i.end);    }    /** 比较两个区间的下边界*/    public int compareTo(Object o) {      Interval i = (Interval) o;      if (this.start < i.start) {	return -1;      } else if (this.start > i.start) {	return 1;      } else {	return 0;      }    }    public boolean equals(Object o) {      if (o instanceof Interval) {	Interval i = (Interval) o;	if (i == this) { return true; }	if (this.start == i.start &&	    this.end == i.end) {	  return true;	} else {	  return false;	}      } else {	return false;      }    }    public int hashCode() {      return (new Double(start)).hashCode();    }    public String toString() {      return "[" + start + " - " + end + "]";    }       }  private final List intervals;  /** 构造区间范围的列表*/  public IntervalList(double start, double end) {    intervals = new LinkedList();    intervals.add(new Interval(start, end));  }  /** 构造一个空的区间列表*/   public IntervalList() {    intervals = new LinkedList();  }  /** 构造一个区间列表的拷贝*/  public IntervalList(IntervalList il) {    intervals = new LinkedList(il.intervals);  }  /** 判断一个区间列表是否为空*/  public boolean isEmpty() {    return intervals.size() == 0;  }  /** 获取区间列表中的最小的区间*/  public double min() {    if (intervals.size() == 0) {      return Double.NaN;    }    return ((Interval)intervals.get(0)).start();  }  /**获取区间列表中最大的区间*/  public double max() {    if (intervals.size() == 0) {      return Double.NaN;    }    return ((Interval)intervals.get(intervals.size()-1)).end();  }  /**规范化区间范围使之没有重复*/  private void canonicalize() {    Collections.sort(intervals);    Interval lastElement;    Interval currentElement;        ListIterator iter = intervals.listIterator();    if (!iter.hasNext()) {      return;    }    currentElement = (Interval) iter.next();    while (iter.hasNext()) {      lastElement = currentElement;      currentElement = (Interval) iter.next();      if (lastElement.overlaps(currentElement)) {	Interval newElement = lastElement.merge(currentElement);	iter.remove();	iter.previous();	iter.remove();	iter.add(newElement);	currentElement = newElement;      }    }  }  /**增加区间范围*/  public void addInterval(double start, double end) {    addIntervalInternal(start, end);    canonicalize();  }  private void addIntervalInternal(double start, double end) {    intervals.add(new Interval(start, end));  }  /**减小区间范围*/  public void removeInterval(double start, double end) {    removeIntervalInternal(start, end);    canonicalize();  }  private void removeIntervalInternal(double start, double end) {    ListIterator iter = intervals.listIterator();    Interval toRemove = new Interval(start, end);    while (iter.hasNext()) {      Interval curr = (Interval) iter.next();      if (curr.overlaps(toRemove)) {	if (start > curr.start()) {	  if (end < curr.end()) {	    iter.remove();	    iter.add(new Interval(curr.start(), start));	    iter.add(new Interval(end, curr.end()));	  } else {	    iter.remove();	    iter.add(new Interval(curr.start(), start));	  }	} else {	  if (end < curr.end()) {	    iter.remove();	    iter.add(new Interval(end, curr.end()));	  } else {	    iter.remove();	  }	}      }    }  }  /**把一个区间范围增加给另一个区间范围*/  public void addIntervalList(IntervalList il) {    Iterator iter = il.intervals.iterator();    while (iter.hasNext()) {      Interval i = (Interval) iter.next();      addIntervalInternal(i.start(), i.end());    }    canonicalize();  }  /**从一个区间范围中去除一个指定区间范围*/  public void removeIntervalList(IntervalList il) {    Iterator iter = il.intervals.iterator();    while (iter.hasNext()) {      Interval i = (Interval) iter.next();      removeIntervalInternal(i.start(), i.end());    }    canonicalize();  }  /** 去除一个指定的区间范围*/  public void restrictToInterval(double start, double end) {    restrictToInterval(new Interval(start, end));  }  public void restrictToInterval(Interval i) {    ListIterator iter = intervals.listIterator();    while (iter.hasNext()) {      Interval curr = (Interval) iter.next();      if (curr.overlaps(i)) {	iter.set(curr.restrictTo(i));      } else {	iter.remove();      }    }  }    /** 判断该区间长度是否为指定长度*/  public boolean restrictSubIntervalLength(double length) {    // returns true if it changed    boolean changed = false;    ListIterator iter = intervals.listIterator();    while (iter.hasNext()) {      Interval curr = (Interval) iter.next();      Interval n = curr.restrictLength(length);      if (!n.equals(curr)) {	changed = true;	iter.set(n);      }    }    return changed;  }  /**递增的迭代序号*/  public Iterator iterator() {    return (Collections.unmodifiableList(intervals)).iterator();  }  public boolean equals(Object o) {    if (o instanceof IntervalList) {      IntervalList il = (IntervalList) o;      return intervals.equals(il.intervals);    }    return false;  }  public int hashCode() {    return intervals.hashCode();  }  public String toString() {    return intervals.toString();  }}