package physics;/**************************************************************************** * Copyright (C) 1999-2001 by the Massachusetts Institute of Technology, *                     Cambridge, Massachusetts. * ***************************************************************************/import java.awt.geom.Point2D;import java.io.Serializable;/** 用来表示二维坐标*/public final class Vect implements Serializable {  private Angle theta;  private double r;  private int mode; // -1 for r-theta, +1 for x-y, 0 for both  private double x;  private double y;  /** 长度为0的向量 */  public static final Vect ZERO = new Vect(0.0, 0.0, 0.0, Angle.ZERO);  /** x轴方向的单位向量 */  public static final Vect X_HAT = new Vect(1.0, 0.0, 1.0, Angle.ZERO);  /** y方向的单位向量 */  public static final Vect Y_HAT = new Vect(0.0, 1.0, 1.0, Angle.DEG_90);  /** 构造一个angle角度方向的单位向量*/  public Vect(Angle angle) {    this(angle, 1.0);  }  /** 构造一个angle角度和length长度的向量*/  public Vect(Angle angle, double length) {    if (angle == null) throw new IllegalArgumentException();    if (length == 0.0) {      theta = Angle.ZERO;      r = 0.0;    } else if (length > 0.0) {      theta = angle;      r = length;    } else {      theta = angle.plus(Angle.RAD_PI);      r = -length;    }    mode = -1;  }  /** 构造一个坐标系中的向量*/  public Vect(double x, double y) {    this.x = x;    this.y = y;    mode = 1;  }  private Vect(double x, double y, double r, Angle theta) {    this.x = x;    this.y = y;    this.r = r;    this.theta = theta;    mode = 0;  }  /** 构造一个向量 */  public Vect(Point2D p) {    this(p.getX(), p.getY());  }  /** 获取xy坐标值 */  private void computeXY() {    if (mode < 0) {      x = r * theta.cos();      y = r * theta.sin();      mode = 0;    }  }  /** 计算向量在极坐标系中的角度*/  private void computeRT() {    if (mode > 0) {      r = Math.sqrt((x * x) + (y * y));      if (r == 0.0) {        theta = Angle.ZERO;      } else {        theta = new Angle(x, y);      }      mode = 0;    }  }  /** 返回向量在极坐标系中的角度*/  public Angle angle() {    computeRT();    return theta;  }  /** 获取向量的长度*/  public double length() {    computeRT();    return r;  }  /** 获取向量在笛卡尔坐标系中的水平坐标 */  public double x() {    computeXY();    return x;  }  /** 获取向量在笛卡尔坐标系中的竖直坐标*/  public double y() {    computeXY();    return y;  }  /** 获取两个向量的距离*/  public double distanceSquared(Vect b) {    computeXY();    b.computeXY();        double width = this.x - b.x;    double height = this.y - b.y;    return ((width * width) + (height * height));  }  /** 计算两个向量的和*/  public Vect plus(Vect b) {    computeXY();    b.computeXY();    return new Vect(this.x + b.x, this.y + b.y);  }  /** 计算两个向量的差 */  public Vect minus(Vect b) {    computeXY();    b.computeXY();    return new Vect(this.x - b.x, this.y - b.y);  }  /** 计算一个向量旋转一定角度后的新向量*/  public Vect rotateBy(Angle a) {    computeRT();    return new Vect(this.theta.plus(a), r);  }  /** 计算一个向量水平翻转后的新向量*/  public Vect neg() {    if (mode < 0) {      return rotateBy(Angle.RAD_PI);    } else if (mode > 0) {      return new Vect(-x, -y);    } else {      // mode == 0      return new Vect(-x, -y, r, theta.plus(Angle.RAD_PI));    }  }  /** 计算一个向量按一定比例缩放后的新向量*/  public Vect times(double amt) {    if (mode < 0) {      return new Vect(theta, r * amt);    } else if (mode > 0) {      return new Vect(x*amt, y*amt);    } else {      // mode == 0      return new Vect(x*amt, y*amt, r*amt, theta);    }  }  /** 计算该向量的正交向量*/  public Vect projectOn(Vect b) {    b.computeRT();    return new Vect(b.theta, this.dot(b));  }  /** 得到该向量方向的单位向量*/  public Vect unitSize() {    computeRT();    return new Vect(theta, 1.0);  }  /** 计算向量的点积*/  public double dot(Vect b) {    if (mode < 0 && b.mode < 0) {      return r * theta.minus(b.theta).cos();    } else {      computeXY();      b.computeXY();      return x*b.x + y*b.y;    }  }  /** 构建一个对应坐标的Point2D对象*/  public Point2D.Double toPoint2D()  {    computeXY();    return new Point2D.Double(x, y);  }  public String toString() {    return "<" + x() + "," + y() + ">";  }  public boolean equals(Vect v) {    if (v == null) return false;    if (mode < 0 && v.mode < 0) {      return ((this.r == v.r) && this.theta.equals(v.theta));    } else {      computeXY();      v.computeXY();      return (this.x == v.x) && (this.y == v.y);    }  }  public boolean equals(Object o) {    return (o instanceof Vect) && this.equals((Vect) o);  }  public int hashCode() {    return (new Double(x())).hashCode() + (new Double(y())).hashCode();  }}