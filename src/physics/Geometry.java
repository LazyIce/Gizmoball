package physics;import java.lang.Double; // import statement added to mollify javadocimport java.util.Iterator;import java.io.Serializable;/**************************************************************************** * Copyright (C) 1999-2001 by the Massachusetts Institute of Technology, *                       Cambridge, Massachusetts. * ***************************************************************************//** *Geometry 用来模拟对象间的物理相互作用 * *Geometry 主要描述下面3个概念类 * object  - 球或者障碍物 * ball    - 一个有位置和速度的小球 * bouncer - 具有位置和角速度的线段 * * Geometry 主要的作用碰撞检测和响应 * 1.调用timeUntilCollision()方法来检测计算小球与每个障碍物间或者小球与其他小球间的发生碰撞时间 * 并取最小值mintime为下一次的碰撞时间 * * 2.更新经过mintime后小球与障碍物的位置。此时，小球与障碍物即将发生碰撞，小球与障碍物是相连接的 * * 3.调用reflect()方法来计算碰撞后小球速度的变化 * * 4.更新小球的速度并循环重新执行第一步 * **/public class Geometry {  //单实例模式  private Geometry() {  }  private static GeometryInterface geometry = new GeometryImpl();  /** 改变接口的实现对象*/  public static void setGeometry(GeometryInterface impl) {    if (impl == null) {       throw new IllegalArgumentException();    }     geometry = impl;  }  /**   *设置参数maximumForesight,useDoughnut,numberOfSlices   *   * maximumForesight 程序运行碰撞检测功能的时间，默认设置为+Inf   *   * useDoughnut 当为true时，timeUntilRotating()方法会进行额外的计算减少碰撞检测的时间   *   * numberOfSlices 将进行碰撞检测的时间进行分片   **/  public static void setTuningParameters(double maximumForesight, boolean useDoughnut, int numberOfSlices) {    if (useDoughnut) {      setGeometry(new GeometryImpl(maximumForesight, numberOfSlices));    } else {      setGeometry(new SimpleGeometry(maximumForesight, numberOfSlices));    }  }  /** 设置maximumForesight的值*/  public static void setForesight(double maximumForesight) {    if (maximumForesight <= 0.1) {      setGeometry(new SimpleGeometry(maximumForesight, 15));    } else {      setGeometry(new GeometryImpl(maximumForesight, 15));    }  }  /** 存放一组两个double数据的记录*/  public static class DoublePair implements Serializable  {    public final double d1;    public final double d2;    /** 构造一对DoublePair*/    public DoublePair (double d1, double d2) {      this.d1 = d1;      this.d2 = d2;    }    /** 构造一对值相同的DoublePair*/    public DoublePair (double both) {      this(both, both);    }    /** 判断这对数中的数字是否是有限大的*/    public boolean areFinite() {      return !Double.isInfinite(d1) && !Double.isInfinite(d2) &&	!Double.isNaN(d1) && !Double.isNaN(d2);    }    public String toString() {      return "[" + d1 + "," + d2 + "]";    }    /** 判断两对数是否相等*/    public boolean equals(Object o) {      return (o instanceof DoublePair) && equals((DoublePair) o);    }    public boolean equals(DoublePair p) {      if (p == null) return false;      return (d1 == p.d1) && (d2 == p.d2);    }    /** 获取这对数字在哈希表中的哈希码*/    public int hashCode() {      return (new Double(d1)).hashCode() + (new Double(d2)).hashCode();    }  }  /** 存放一对两个向量的记录*/  public static class VectPair implements Serializable  {    public final Vect v1;    public final Vect v2;    /** 构造一对向量*/    public VectPair(Vect v1, Vect v2) {      this.v1 = v1;      this.v2 = v2;    }    public String toString() {      return "[" + v1 + "," + v2 + "]";    }    public boolean equals(Object o) {      return (o instanceof VectPair) && equals((VectPair) o);    }    /** 判断两对向量组是否相等*/    public boolean equals(VectPair p) {      if (p == null) return false;      return	((v1 == null) ? (p.v1 == null) : v1.equals(p.v1)) &&	((v2 == null) ? (p.v2 == null) : v2.equals(p.v2));    }    /** 获取向量在哈希表中的哈希码*/    public int hashCode() {      return	((v1 == null) ? 0 : (3 * v1.hashCode())) +	((v2 == null) ? 0 : (7 * v2.hashCode()));    }  }  /** 无穷大的doublePair*/  public static final DoublePair DOUBLE_PAIR_NAN =    new DoublePair(Double.NaN);  /** 获取一元二次方程的一组解*/  public static DoublePair quadraticSolution(double a, double b, double c) {    return geometry.quadraticSolution(a, b, c);  }  /** 获取一元二次方程的一组解中较小的解*/  public static double minQuadraticSolution(double a, double b, double c) {    return geometry.minQuadraticSolution(a, b, c);  }  /***************************************************************************   *   * METHODS FOR LINE SEGMENTS   *   * 计算点(a,b)到线段(两个端点的坐标分别为(x,y),(w,z))的最短距离。   * 可以计算点到线段上每个点的距离然后取最小值。   * 线段上的点的坐标可以表示为关于s的函数：j[s] = x+(w-x)s, k[s]=y+(z-y)s   * 所以点(a,b)到线段上的点的距离的平方和为：(a-j[s])^2+(b-k[s])^2   * 对s求导数并另其为0，可以得到点到线段的距离的平方和为   * (b(x-w) - a(y-z) + (w y - x z))^2 / ((x-w)^2 + (y-z)^2)   *同时可以得到垂足的坐标为：minX = j[minS], minY = k[minS]   * 其中minS = ((w-x)(a-x) + (z-y)(b-y)) / ((w-x)^2 + (y-z)^2)   * 当点(a,b)随着时间t位置发生改变时，另点的坐标与时间t的关系是：   * a[t] = u t + c, b[t] = v t + d.   * 计算何时点(a,b)到线段的距离刚好为r   *二次方程为 At^2 + Bt + C   *其中A = (v(x-w) - u(y-z))^2   * B = 2*(v(x-w) - u(y-z))*(d(x-w) - c(y-z) + (w y - x z))   * C = (d(x-w) - c(y-z) + (w y - x z))^2   *令Cprime = C - r^2*((x-w)^2 + (y-z)^2)   * 可以得到 t = (-B +/- Sqrt(B^2 - 4 A Cprime)) / (2 A)   *   ***************************************************************************/  /** 获取点到线段的垂足坐标*/  static public Vect perpendicularPoint(LineSegment line, Vect point) {    return geometry.perpendicularPoint(line, point);  }  /**获取点到线段的所有的垂足的坐标 */  public static Vect perpendicularPointWholeLine(LineSegment line, Vect point) {      return geometry.perpendicularPointWholeLine(line, point);  }  /**   *通过碰撞前的速度、弹性碰撞后的速度、弹性系数来计算非弹性碰撞后的速度。   *弹性系数为1时，即为弹性碰撞，弹性系数为0时即小球的动能被全部吸收   **/  public static Vect applyReflectionCoeff(Vect incidentVect, Vect reflectedVect, double rCoeff) {    return geometry.applyReflectionCoeff(incidentVect, reflectedVect, rCoeff);  }  /** 计算小球发生碰撞的时间*/  public static double timeUntilWallCollision(LineSegment line, Circle ball, Vect velocity) {    return geometry.timeUntilWallCollision(line, ball, velocity);  }  /** 计算小球碰到边界反弹后的速度（考虑摩擦系数）*/  public static Vect reflectWall(LineSegment line, Vect velocity, double reflectionCoeff) {    return geometry.reflectWall(line, velocity, reflectionCoeff);  }  /** 计算小球碰到边界反弹后的速度（不考虑摩擦）*/  public static Vect reflectWall(LineSegment line, Vect velocity) {    return geometry.reflectWall(line, velocity);  }  /****************************************************************************   *   * METHODS FOR CIRCLES   *   ***************************************************************************/  /** 获取两点的距离的平方*/   static public double distanceSquared(Vect v1, Vect v2) {     return geometry.distanceSquared(v1, v2);   }   static public double distanceSquared(double x1, double y1, double x2, double y2) {     return geometry.distanceSquared(x1, y1, x2, y2);   }  /**计算运动的小球与圆形障碍物发生碰撞的时间*/  static public double timeUntilCircleCollision(Circle circle, Circle ball, Vect velocity) {    return geometry.timeUntilCircleCollision(circle, ball, velocity);  }  /** 计算小球与圆形障碍物发生碰撞后反弹的速度（考虑摩擦）*/  public static Vect reflectCircle(Vect circle, Vect ball, Vect velocity, double reflectionCoeff) {    return geometry.reflectCircle(circle, ball, velocity, reflectionCoeff);  }  /**计算小球与圆形障碍物碰撞反弹后的速度（不考虑摩擦）*/  public static Vect reflectCircle(Vect circle, Vect ball, Vect velocity) {    return geometry.reflectCircle(circle, ball, velocity);  }  /****************************************************************************   *   * METHODS FOR ROTATING LINE SEGMENTS AND CIRCLES   *   ***************************************************************************/  /**计算一个点经过旋转中心旋转一定角度后的新坐标*/  public static Vect rotateAround(Vect point, Vect cor, Angle a) {    return geometry.rotateAround(point, cor, a);  }  /** 计算一个线段经过旋转中心旋转一定角度后的新线段*/  public static LineSegment rotateAround(LineSegment line, Vect cor, Angle a) {    return geometry.rotateAround(line, cor, a);  }  /** 计算一个圆形障碍物绕旋转中心旋转一定角度后的新的圆形*/  public static Circle rotateAround(Circle circle, Vect cor, Angle a) {    return geometry.rotateAround(circle, cor, a);  }  /** 计算点与圆形障碍物碰撞的时间*/  public static DoublePair timeUntilCircleCollision(Circle circle, Vect point, Vect velocity)  {    return geometry.timeUntilCircleCollision(circle, point, velocity);  }    /**计算小球与旋转的线段发生碰撞的时间*/  public static double timeUntilRotatingWallCollision(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity)  {    return geometry.timeUntilRotatingWallCollision(line, center, angularVelocity, ball, velocity);  }  /** 计算小球与旋转的线段碰撞反弹后的速度（不考虑摩擦）*/  public static Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity) {    return geometry.reflectRotatingWall(line, center, angularVelocity, ball, velocity);  }  /** 计算小球与旋转的线段碰撞反弹后的速度（考虑摩擦）*/  public static Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity, double reflectionCoeff)  {    return geometry.reflectRotatingWall(line, center, angularVelocity, ball, velocity, reflectionCoeff);  }  /**计算小球与旋转的圆形障碍物发生碰撞的时间*/  public static double timeUntilRotatingCircleCollision(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity)  {    return geometry.timeUntilRotatingCircleCollision(circle, center, angularVelocity, ball, velocity);  }  /**计算小球与旋转的圆形障碍物碰撞后反弹的速度（不考虑摩擦）*/  public static Vect reflectRotatingCircle(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity) {    return geometry.reflectRotatingCircle(circle, center, angularVelocity, ball, velocity);  }  /** 计算小球与旋转的圆形障碍物碰撞反弹后的速度（考虑摩擦）*/  public static Vect reflectRotatingCircle(Circle circle,					   Vect center,                                           double angularVelocity,					   Circle ball,                                           Vect velocity,					   double reflectionCoeff)  {    return geometry.reflectRotatingCircle(circle,					  center,					  angularVelocity,					  ball,					  velocity,					  reflectionCoeff);  }  /****************************************************************************   *   * METHODS FOR MULTI-BALL SIMULATIONS   *   ***************************************************************************/  /**计算两个小球发生碰撞的时间*/  public static double timeUntilBallBallCollision(Circle ball1, Vect   vel1, Circle ball2, Vect   vel2) {    return geometry.timeUntilBallBallCollision(ball1, vel1, ball2, vel2);  }  /** 计算两个小球发生碰撞后的速度*/  public static VectPair reflectBalls(Vect center1, double mass1, Vect velocity1, Vect center2, double mass2, Vect velocity2) {    return geometry.reflectBalls(center1, mass1, velocity1, center2, mass2, velocity2);  }}