package physics;import java.lang.Double; // import statement added to mollify javadoc/**************************************************************************** * Copyright (C) 1999, 2000 by the Massachusetts Institute of Technology, *                       Cambridge, Massachusetts. * ***************************************************************************//** 描述力*/public class Newton {  //单实例模式  private Newton() {  }    /**记录某点对应的函数和其导数*/  public final static class Result {    public final double f;    public final double f_prime;    /** 构造函数*/    public Result(double f, double f_prime) {      this.f = f;      this.f_prime = f_prime;    }    /** 判断数值是否无穷大*/    public boolean undefined() {      return Double.isNaN(f) || Double.isNaN(f_prime);    }    /** 判断函数数值的符号 **/    public boolean funcSignChance(Result other) {      return (f * other.f <= 0);    }    /** 判断导数数值的符号**/    public boolean derivativeSignChance(Result other) {      return (f_prime * other.f_prime <= 0);    }    /** 得到funcSignChange() || derivativeSignChange() **/    public boolean signChange(Result other) {      return (f * other.f <= 0) || (f_prime * other.f_prime <= 0);    }    public String toString() {      return "f(t)=" + f + ";f'(t)=" + f_prime + "";    }  }  /** 函数解集**/  public static final Result UNDEFINED = new Result(Double.NaN, Double.NaN);  /**定义可以根据牛顿法求根的模块接口*/  public static interface Function {    /** 获取函数取值*/    public abstract Result evaluate(double t);  }  private static final int MAX_STEPS = 30;  private static final double epsilon =  0.000000001;  /**同牛顿法逼近方程的解，逼近的区间范围是[t_min,t_max]，间隔是t_step */  public static double findRoot(Function function, 				double t_min,				double t_max,				double t_step)  {    Result eval = UNDEFINED;    for (double t = t_min; t < t_max + t_step; t += t_step) {      Result old = eval;      eval = function.evaluate(t);      if (eval.undefined()) {	continue;      }      if (eval.signChange(old)) {	double root = findRoot(function, 			       (old.f_prime <= 0) ? t - t_step : t);	if ((t - t_step <= root) && (root <= t)) {	  return root;	}      }    }    return Double.NaN;  }  /**用牛顿法求方程的根*/  public static double findRoot(Function function,				double initial_t)  {    double t = initial_t;        for (int count = 0; count < MAX_STEPS; count++) {      Result eval = function.evaluate(t);      if (eval.undefined()) {	return Double.NaN;      }      double t_next = t - eval.f/eval.f_prime;            if (Math.abs(t_next - t) < epsilon) {	if (Math.abs(eval.f) < 1000*epsilon) {	  return t_next;	} else {	  return Double.NaN;	}      }      t = t_next;    }    return Double.NaN;  }}