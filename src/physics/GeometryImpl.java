package physics;import java.lang.Double; // import statement added to mollify javadocimport java.util.Iterator;import physics.Geometry.VectPair;import physics.Geometry.DoublePair;/**************************************************************************** * Copyright (C) 1999-2001 by the Massachusetts Institute of Technology, *                       Cambridge, Massachusetts. ***************************************************************************//** * GeometryImpl是GeometryInterface接口的默认的实现。 * 在Geometry的实例中会用到Geometry。 * * GeometryImpl通过maximumForesight和searchSlices两个参数来控制行为。 * * maximumForesight是游戏进行碰撞检测的最大运行时间。 * * searchSlices值越大越容易调用timeUntilRotating()方法找到碰撞时间。 **/public class GeometryImpl implements GeometryInterface{  protected final double maximumForesight;  protected final int searchSlices;    /** 构造函数**/  public GeometryImpl() {    this(Double.POSITIVE_INFINITY, 15);  }  public GeometryImpl(double maximumForesight, int searchSlices) {    if (!((maximumForesight >= 0.0) && (searchSlices >= 1))) {      throw new IllegalArgumentException();    }    this.maximumForesight = maximumForesight;    this.searchSlices = searchSlices;  }  /** 二次方程求解**/  public DoublePair quadraticSolution(double a, double b, double c) {    if (a == 0.0) {      if (b == 0.0) {	return Geometry.DOUBLE_PAIR_NAN;      } else {	return new DoublePair(-c/b);      }    }    else {      double discriminant = (b * b) - (4.0 * a * c);      if (discriminant < 0.0) {	return Geometry.DOUBLE_PAIR_NAN;      } else {	double sqrt = Math.sqrt(discriminant);	double twoA = 2.0 * a;	double lesserNum = -b - sqrt;	double greaterNum = -b + sqrt;	if (a > 0) {	  return new DoublePair(lesserNum/twoA, greaterNum/twoA);	} else {	  return new DoublePair(greaterNum/twoA, lesserNum/twoA);	}      }    }  }  /** 二次方程的一组解中较小的解 */  public double minQuadraticSolution(double a, double b, double c) {    return quadraticSolution(a, b, c).d1;  }  /** 计算垂足的坐标 */  public Vect perpendicularPoint(LineSegment line, Vect point) {    double x1 = line.p1().x(),      y1 = line.p1().y(),      x2 = line.p2().x(),      y2 = line.p2().y(),      a  = point.x(),      b  = point.y();    double height = (y2 - y1);    double width = (x2 - x1);    double lengthSquared = (height * height) + (width * width);    double fraction = (((width * (a - x1)) + (height * (b - y1))) / lengthSquared);    if (fraction < 0 || fraction > 1) {      return null;    }    double pptx = x1 + fraction * width;    double ppty = y1 + fraction * height;    return new Vect(pptx, ppty);  }  /** 计算垂足的坐标*/  public Vect perpendicularPointWholeLine(LineSegment line, Vect point) {    double x1 = line.p1().x(),      y1 = line.p1().y(),      x2 = line.p2().x(),      y2 = line.p2().y(),      a  = point.x(),      b  = point.y();    double height = (y2 - y1);    double width = (x2 - x1);    double lengthSquared = (height * height) + (width * width);    double fraction = (((width * (a - x1)) + (height * (b - y1))) / lengthSquared);    double pptx = x1 + fraction * width;    double ppty = y1 + fraction * height;    return new Vect(pptx, ppty);  }  /** 弹性碰撞的速度通过反弹系数转化为非弹性碰撞的速度*/  public Vect applyReflectionCoeff(Vect incidentVect, Vect reflectedVect, double rCoeff) {    return incidentVect.plus(reflectedVect.minus(incidentVect).times(0.5 + 0.5 * rCoeff));  }  /** 计算小球与线段发生碰撞的时间*/  public double timeUntilWallCollision(LineSegment line, Circle ball, Vect velocity) {    double x1 = line.p1().x(),      y1 = line.p1().y(),      x2 = line.p2().x(),      y2 = line.p2().y(),      a  = ball.getCenter().x(),      b  = ball.getCenter().y(),      radius = ball.getRadius(),      va = velocity.x(),      vb = velocity.y();    double width = x2 - x1;    double height = y2 - y1;    double F = ((va * height) - (vb * width));    double G = ((a * height) - (b * width) + ((x2 * y1) - (x1 * y2)));    double H = ((width * width) + (height * height));    double A = F * F;    double B = 2.0 * F * G;    double C = G * G;    double Cprime = C - (radius * radius * H);    double collisionTime = minQuadraticSolution(A, B, Cprime);    if (Double.isNaN(collisionTime)) {      return Double.POSITIVE_INFINITY;    }    double cX = a + (collisionTime * va);    double cY = b + (collisionTime * vb);    double minS = ((width * (cX - x1)) + (height * (cY - y1))) /      ((width * width) + (height * height));    if ((0.0 <= minS) && (minS < 1.0)) {      if (collisionTime > 0) {	return collisionTime;      } else {	double impactX = x1 + minS * width;	double impactY = y1 + minS * height;	if (velocity.dot(new Vect(a - impactX, b - impactY)) >= 0) {	  return Double.POSITIVE_INFINITY;	} else {	  return 0;	}      }    } else {      return Double.POSITIVE_INFINITY;    }  }  /** 计算小球与边界发生碰撞反弹后的速度（考虑摩擦） */  public Vect reflectWall(LineSegment line, Vect velocity, double reflectionCoeff) {    return applyReflectionCoeff(velocity, reflectWall(line, velocity), reflectionCoeff);  }  /** 计算小球与边界发生碰撞反弹后的速度（不考虑摩擦）*/  public Vect reflectWall(LineSegment line, Vect velocity)  {    double length = velocity.length();    if (length == 0.0) {      return velocity;    }    Angle theta = line.angle();    Angle alpha = velocity.angle();    Angle phi = theta.plus(theta).minus(alpha);    return new Vect(phi, length);  }  /****************************************************************************   *   * METHODS FOR CIRCLES   *   ***************************************************************************/    /** 获取两点的距离的平方*/   public double distanceSquared(Vect v1, Vect v2) {      double height = (v2.y() - v1.y());      double width = (v2.x() - v1.x());      return ((width * width) + (height * height));   }   public double distanceSquared(double x1, double y1,				 double x2, double y2) {      double height = y2 - y1;      double width = x2 - x1;      return ((width * width) + (height * height));   }    /**计算运动的小球与圆形障碍物发生碰撞的时间*/  public double timeUntilCircleCollision(Circle circle,					 Circle ball,					 Vect velocity) {    Vect xy = circle.getCenter(),         ab = ball.getCenter();    double x       = xy.x(),           y       = xy.y(),           radius1 = circle.getRadius(),	   a       = ab.x(),	   b       = ab.y(),           radius2 = ball.getRadius(),	   va      = velocity.x(),	   vb      = velocity.y();    double distance = radius1 + radius2;    double width = a - x;    double height = b - y;    double A = ((va * va) + (vb * vb));    double B = 2.0 * ((va * width) + (vb * height));    double C = (width * width) + (height * height) - (distance * distance);    double ans = minQuadraticSolution(A, B, C);    if (Double.isNaN(ans)) {      return Double.POSITIVE_INFINITY;    } else if (ans <= 0) {      Vect impactDirection = ab.minus(xy);      if (impactDirection.dot(velocity) >= 0) {	return Double.POSITIVE_INFINITY;      } else {	return 0;      }    } else {      // ans > 0 && ans <= +inf      return ans;    }  }    /** 计算小球与圆形障碍物发生碰撞后反弹的速度（考虑摩擦）*/  public Vect reflectCircle(Vect circle,			    Vect ball,			    Vect velocity, 			    double reflectionCoeff) {    return applyReflectionCoeff(velocity,				reflectCircle(circle, ball, velocity),				reflectionCoeff);  }    /**计算小球与圆形障碍物碰撞反弹后的速度（不考虑摩擦）*/  public Vect reflectCircle(Vect circle,			    Vect ball,			    Vect velocity)  {    double length = velocity.length();    if (length == 0.0) {      return velocity;    }    Vect incidence = circle.minus(ball);    Angle theta = incidence.angle().plus(Angle.RAD_PI_OVER_TWO);    // outgoing angle    Angle phi = theta.plus(theta).minus(velocity.angle());    return new Vect(phi, length);  }  /****************************************************************************   *   * METHODS FOR ROTATING LINE SEGMENTS AND CIRCLES   *   ***************************************************************************/    /**计算一个点经过旋转中心旋转一定角度后的新坐标*/  public Vect rotateAround(Vect point, Vect cor, Angle a) {    Vect original = point.minus(cor);    Angle newAng = original.angle().plus(a);    Vect after = new Vect(newAng, original.length());    return cor.plus(after);  }    /** 计算一个线段经过旋转中心旋转一定角度后的新线段*/  public LineSegment rotateAround(LineSegment line, Vect cor, Angle a) {    return new LineSegment(rotateAround(line.p1(), cor, a),		    rotateAround(line.p2(), cor, a));  }    /** 计算一个圆形绕旋转中心旋转一定角度后的新的圆形*/  public Circle rotateAround(Circle circle, Vect cor, Angle a) {    return new Circle(rotateAround(circle.getCenter(), cor, a),		      circle.getRadius());  }    /** 计算点与圆形障碍物碰撞的时间*/  public DoublePair timeUntilCircleCollision(Circle circle, Vect point, Vect velocity)  {    final double r = circle.getRadius();    final double x = point.x() - circle.getCenter().x();    final double y = point.y() - circle.getCenter().y();    final double vx = velocity.x();    final double vy = velocity.y();    final double a = vx * vx + vy * vy;    final double b = 2 * (x * vx + y * vy);    final double c = x * x + y * y - r * r;    DoublePair result = quadraticSolution(a, b, c);    if (Double.isNaN(result.d1)) {      return new DoublePair(Double.POSITIVE_INFINITY);    }    return result;  }    /** 将时间间隔限制为仅包含两个圆形切片（一个旋转）重叠的时间段。*/  private void restrictIntervalByAngle(IntervalList intervals,				       double alpha,				       double beta,				       double omega,				       double phi,				       double width,				       boolean bigSlice) {    if (alpha < 0) alpha += 2*Math.PI;    if (beta < 0) beta += 2*Math.PI;    double d = beta - alpha;    if (d < 0 ) d += 2*Math.PI;        if ((d < Math.PI && bigSlice) ||	(d > Math.PI && !bigSlice)) {      double t = alpha;      alpha = beta;      beta = t;    }        restrictIntervalByAngle(intervals, alpha, beta, omega, phi, width);  }  private void restrictIntervalByAngle(IntervalList intervals,				       double alpha,				       double beta,				       double omega,				       double phi,				       double width) {    if (phi < 0) phi += 2*Math.PI;    if (alpha < 0) alpha += 2*Math.PI;    if (beta < 0) beta += 2*Math.PI;    if (alpha > 2*Math.PI || alpha < 0 || Double.isNaN(alpha)) {      throw new IllegalArgumentException();    }    if (beta > 2*Math.PI || beta < 0 || Double.isNaN(beta)) {      throw new IllegalArgumentException();    }    if (phi > 2*Math.PI || phi < 0 || Double.isNaN(phi)) {      throw new IllegalArgumentException();    }    if (width < 0 || width > 2*Math.PI || Double.isNaN(width)) {      throw new IllegalArgumentException();    }    //  {alpha beta phi width}  [0, 2pi]    if (omega < 0) {      omega = -omega;      alpha = -alpha;      beta  = -beta;      phi   = phi + width;      if (phi > 2*Math.PI) {	phi -= 2*Math.PI;      }      phi   = -phi;            if (alpha < 0) alpha += 2*Math.PI;      if (beta < 0) beta += 2*Math.PI;      if (phi  < 0) phi  += 2*Math.PI;      double t = alpha;      alpha = beta;      beta = t;    }    // omega >= 0    alpha -= phi;    beta -= phi;        if (alpha < 0) alpha += 2*Math.PI;    if (beta < 0) beta += 2*Math.PI;    // phi=0    double t = Double.NaN;    double nextT = 0;    boolean validRegion = (alpha > beta || alpha < width);        double twiceAround = 2 * (2*Math.PI) / omega;    while ((nextT < twiceAround) && (t != nextT)) {      t = nextT;      if (validRegion) {	double angleToBeta = beta - t*omega;	while (angleToBeta < 0) angleToBeta += 2*Math.PI;	// beta is next	nextT = t + angleToBeta  / omega;	validRegion = false;      }	else {	double angleToAlpha = alpha - t*omega - width;	while (angleToAlpha < 0) angleToAlpha += 2*Math.PI;	// alpha is next	nextT = t + angleToAlpha / omega;	intervals.removeInterval(t, nextT);	validRegion = true;      }    }    t = nextT;    if (validRegion == false && t < twiceAround) {      intervals.removeInterval(t, twiceAround);    }  }  /** 考虑到球的路径和在圆中旋转的路径   * 限制了他们可能碰撞的可能时间段。*/  protected IntervalList restrictSearchInterval(IntervalList intervals,						double inner_radius,						double outer_radius,						double phi_1,						double phi_2,						double omega,						Vect center,						Circle ball,						Vect velocity) {    if (velocity.length() == 0) {      Vect ballCenter = ball.getCenter();      double dist = ballCenter.minus(center).length();      if (dist - ball.getRadius() < outer_radius) {	intervals.restrictSubIntervalLength(2*Math.PI/Math.abs(omega));	return intervals;      } else {	return new IntervalList();      }    }    //计算小球与外圆相交的时间范围    DoublePair dp =      timeUntilCircleCollision(new Circle(center, 					  outer_radius + ball.getRadius()),			       ball.getCenter(), velocity);    if (!dp.areFinite()) {      return new IntervalList();    }    intervals.restrictToInterval(dp.d1, dp.d2);    if (intervals.isEmpty()) {      return intervals;    }        if (inner_radius - ball.getRadius() > 0) {      dp = 	timeUntilCircleCollision(new Circle(center, 					    inner_radius - ball.getRadius()),				 ball.getCenter(), velocity);      if (dp.areFinite()) {	intervals.removeInterval(dp.d1, dp.d2);      }    }    if (intervals.min() < 0) {      intervals.removeInterval(intervals.min(), 0.0);    }    intervals.restrictSubIntervalLength(2*2*Math.PI/Math.abs(omega));    if (intervals.isEmpty()) {      return intervals;    }    Vect ballVelocityNormal = velocity.rotateBy(Angle.RAD_PI_OVER_TWO);    if (ballVelocityNormal.dot(ball.getCenter().minus(center)) < 0) {      ballVelocityNormal = ballVelocityNormal.neg();    }    ballVelocityNormal = ballVelocityNormal.unitSize().times(ball.getRadius());        Vect farRailStartPoint = ball.getCenter().plus(ballVelocityNormal);    Vect nearRailStartPoint = ball.getCenter().minus(ballVelocityNormal);    DoublePair farOuterIntersections = timeUntilCircleCollision(new Circle(center, outer_radius),            farRailStartPoint, velocity);    DoublePair nearOuterIntersections =      timeUntilCircleCollision(new Circle(center, outer_radius),			       nearRailStartPoint, velocity);    DoublePair farInnerIntersections =      timeUntilCircleCollision(new Circle(center, inner_radius),			       farRailStartPoint, velocity);    DoublePair nearInnerIntersections =      timeUntilCircleCollision(new Circle(center, inner_radius),			       nearRailStartPoint, velocity);    Vect centerToFarBounds =      perpendicularPointWholeLine(new LineSegment(farRailStartPoint,						  farRailStartPoint.plus(velocity)), center);    Vect centerToNearBounds =      perpendicularPointWholeLine(new LineSegment(nearRailStartPoint,						  nearRailStartPoint.plus(velocity)), center);    // 计算相交的位置    Vect farOuterVect1 = farRailStartPoint.plus(velocity.times(farOuterIntersections.d1));    Vect farOuterVect2 = farRailStartPoint.plus(velocity.times(farOuterIntersections.d2));    Vect nearOuterVect1 = nearRailStartPoint.plus(velocity.times(nearOuterIntersections.d1));    Vect nearOuterVect2 = nearRailStartPoint.plus(velocity.times(nearOuterIntersections.d2));    Vect farInnerVect1 = farRailStartPoint.plus(velocity.times(farInnerIntersections.d1));    Vect farInnerVect2 = farRailStartPoint.plus(velocity.times(farInnerIntersections.d2));    Vect nearInnerVect1 = nearRailStartPoint.plus(velocity.times(nearInnerIntersections.d1));    Vect nearInnerVect2 = nearRailStartPoint.plus(velocity.times(nearInnerIntersections.d2));    //计算相交的角度    double farOuterAngle1 = farOuterVect1.minus(center).angle().radians();    double farOuterAngle2 = farOuterVect2.minus(center).angle().radians();    double nearOuterAngle1 = nearOuterVect1.minus(center).angle().radians();    double nearOuterAngle2 = nearOuterVect2.minus(center).angle().radians();    double farInnerAngle1 = farInnerVect1.minus(center).angle().radians();    double farInnerAngle2 = farInnerVect2.minus(center).angle().radians();    double nearInnerAngle1 = nearInnerVect1.minus(center).angle().radians();    double nearInnerAngle2 = nearInnerVect2.minus(center).angle().radians();        double phi = (phi_1 < phi_2) ? phi_1 : phi_2;    if (phi < 0) phi += 2*Math.PI;    double width = phi_1 - phi_2;    if (width < 0) width = -width;    if (!farInnerIntersections.areFinite()) {      if (!farOuterIntersections.areFinite() &&	  !nearOuterIntersections.areFinite()) {	intervals.restrictSubIntervalLength(2*Math.PI/Math.abs(omega));      } else {	if (centerToFarBounds.dot(centerToNearBounds) > 0) {	  restrictIntervalByAngle(intervals,				  nearOuterAngle1, nearOuterAngle2,				  omega, phi, width, false);	} else {	  if (nearOuterIntersections.areFinite()) {	    intervals.restrictSubIntervalLength(2*Math.PI/Math.abs(omega));	  } else {	    restrictIntervalByAngle(intervals,				    nearInnerAngle1, nearInnerAngle2,				    omega, phi, width, true);	  }	}      }    } else {      if (!farInnerIntersections.areFinite() ||	  !farOuterIntersections.areFinite() ||	  !nearInnerIntersections.areFinite() ||	  !nearOuterIntersections.areFinite()) {	throw new IllegalArgumentException();      }      IntervalList intervals2 = new IntervalList(intervals);      if(centerToFarBounds.dot(centerToNearBounds) > 0) {	restrictIntervalByAngle(intervals,				nearOuterAngle1, farInnerAngle1,				omega, phi, width, false);	restrictIntervalByAngle(intervals2,				farInnerAngle2, nearOuterAngle2, 				omega, phi, width, false);      } else {	restrictIntervalByAngle(intervals,				nearInnerAngle1, farInnerAngle1,				omega, phi, width, false);	restrictIntervalByAngle(intervals,				farInnerAngle2, nearInnerAngle2, 				omega, phi, width, false);      }      intervals.addIntervalList(intervals2);    }    return intervals;  }  /** 获得计算小球与障碍物间距离的方程的解的较小的解*/  private double searchForCollision(Newton.Function distanceFunction, IntervalList intervals) {    Iterator iter = intervals.iterator();    while (iter.hasNext()) {      IntervalList.Interval interval = (IntervalList.Interval) iter.next();      if (interval.start() < 0) {	if (interval.end() < 0) {	  continue;	}	interval = new IntervalList.Interval(0, interval.end());      }      if (interval.end() < interval.start()) {	continue;      }            double t_step = (interval.end() - interval.start()) / searchSlices;      double collisionTime = Newton.findRoot(distanceFunction, 					     interval.start(),					     interval.end(), 					     t_step);            if (collisionTime >= 0) {	Newton.Result result = distanceFunction.evaluate(collisionTime);	if (result.f_prime < 0) {	  return collisionTime;	} else {	  return Double.POSITIVE_INFINITY;	}      }    }    return Double.POSITIVE_INFINITY;  }    /**计算小球与旋转的线段发生碰撞的时间*/  public double timeUntilRotatingWallCollision(LineSegment line, Vect center, double angularVelocity,					       Circle ball, Vect velocity)  {    if (angularVelocity == 0.0) {      return timeUntilWallCollision(line, ball, velocity);    }    final double omega = angularVelocity;    final double x1_0 = line.p1().x();    final double y1_0 = line.p1().y();    final double x2_0 = line.p2().x();    final double y2_0 = line.p2().y();    final double r_x = center.x();    final double r_y = center.y();    final double r_p1_2 = (r_x-x1_0)*(r_x-x1_0) + (r_y-y1_0)*(r_y-y1_0);    final double r_p2_2 = (r_x-x2_0)*(r_x-x2_0) + (r_y-y2_0)*(r_y-y2_0);    final double r_p1   = Math.sqrt(r_p1_2);    final double r_p2   = Math.sqrt(r_p2_2);    final double phi_1  = Math.atan2(y1_0 - r_y, x1_0 - r_x);    final double phi_2  = Math.atan2(y2_0 - r_y, x2_0 - r_x);    final double b_x  = ball.getCenter().x();    final double b_y  = ball.getCenter().y();    final double b_r  = ball.getRadius();    final double vb_x = velocity.x();    final double vb_y = velocity.y();    class RotatingWallDistance implements Newton.Function {      public Newton.Result evaluate(double t) {	double p1_t_cos = r_p1 * Math.cos(omega * t + phi_1);	double p1_t_sin = r_p1 * Math.sin(omega * t + phi_1);	double p2_t_cos = r_p2 * Math.cos(omega * t + phi_2);	double p2_t_sin = r_p2 * Math.sin(omega * t + phi_2);	double x1_t = p1_t_cos + r_x;	double y1_t = p1_t_sin + r_y;	double x2_t = p2_t_cos + r_x;	double y2_t = p2_t_sin + r_y;	double b_x_t = vb_x * t + b_x;	double b_y_t = vb_y * t + b_y;	double height = y2_t - y1_t;	double width  = x2_t - x1_t;	double length_squared = width*width + height * height;	double fraction = (((width  * (b_x_t - x1_t)) +			    (height * (b_y_t - y1_t))) /			   (length_squared));	if (!((0.0 <= fraction) && (fraction <= 1.0))) {	  return new Newton.Result(Double.NaN, Double.NaN);	}	double x_t = x1_t + fraction * width;	double y_t = y1_t + fraction * height;	double dist_sq = (x_t - b_x_t) * (x_t - b_x_t) +	  (y_t - b_y_t) * (y_t - b_y_t);	double f = dist_sq - b_r*b_r;	double x1_t_prime  = -omega * p1_t_sin;	double y1_t_prime  =  omega * p1_t_cos;	double x2_t_prime  = -omega * p2_t_sin;	double y2_t_prime  =  omega * p2_t_cos;	double b_x_t_prime = vb_x;	double b_y_t_prime = vb_y;	double height_prime = y2_t_prime - y1_t_prime;	double width_prime  = x2_t_prime - x1_t_prime;	double length_squared_prime = 2 * width * width_prime +	  2 * height * height_prime;	double fraction_prime =	  ((length_squared * ((width_prime * (b_x_t - x1_t) +			       width * (b_x_t_prime - x1_t_prime)) +			      (height_prime * (b_y_t - y1_t) +			       height * (b_y_t_prime - y1_t_prime))))	   -	   (length_squared_prime * ((width * (b_x_t - x1_t)) +				    (height * (b_y_t - y1_t)))))	  /	  (length_squared * length_squared);	double x_t_prime = x1_t_prime +	  fraction * width_prime +	  fraction_prime * width;	double y_t_prime = y1_t_prime +	  fraction * height_prime +	  fraction_prime * height;	double f_prime =	  2 * (x_t - b_x_t) * (x_t_prime - b_x_t_prime) +	  2 * (y_t - b_y_t) * (y_t_prime - b_y_t_prime);	return new Newton.Result(f, f_prime);      }    }    Newton.Function function = new RotatingWallDistance();    Newton.Result initialDistance = function.evaluate(0);        if (initialDistance.f <= 0) {      if (initialDistance.f_prime >= 0) {	return Double.POSITIVE_INFINITY;      } else {	return 0;      }    }    final double outer_radius = ((r_p1 > r_p2) ? r_p1 : r_p2);    final double inner_radius;    Vect distToCenter = perpendicularPoint(line, center);    if (distToCenter == null) {      inner_radius = ((r_p1 > r_p2) ? r_p2 : r_p1);    } else {      inner_radius = distToCenter.minus(center).length();    }    IntervalList intervals = new IntervalList(0, maximumForesight);    intervals = restrictSearchInterval(intervals, inner_radius, outer_radius, phi_1, phi_2, omega, center, ball, velocity);    return searchForCollision(function, intervals);  }    /** 计算小球与旋转的线段碰撞反弹后的速度（不考虑摩擦）*/  public Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity) {    return reflectRotatingWall(line, center, angularVelocity, ball, velocity, 1.0);  }    /** 计算小球与旋转的线段碰撞反弹后的速度（考虑摩擦）*/  public Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity, double reflectionCoeff)  {    if (angularVelocity == 0.0) {      return reflectWall(line, velocity, reflectionCoeff);    }    double radius = ball.getRadius();    Vect p1 = line.p1().minus(center);    Vect p2 = line.p2().minus(center);    Vect ballCenter = ball.getCenter().minus(center);    line = new LineSegment(p1, p2);    Vect perpPt = perpendicularPoint(line, ballCenter);    if (perpPt == null) {      return velocity;    }    Vect myVel = perpPt.times(angularVelocity).rotateBy(Angle.RAD_PI_OVER_TWO);    Vect relativeV = velocity.minus(myVel);    Vect reflectV = reflectWall(line, relativeV, reflectionCoeff);    Vect absoluteV = myVel.plus(reflectV);    return absoluteV;  }    /**计算小球与旋转的圆形障碍物发生碰撞的时间*/  public double timeUntilRotatingCircleCollision(Circle circle,						 Vect center,						 double angularVelocity,						 Circle ball,						 Vect velocity)  {    if (angularVelocity == 0.0) {      return timeUntilCircleCollision(circle, ball, velocity);    }    final double omega = angularVelocity;    final double c_x  = circle.getCenter().x();    final double c_y  = circle.getCenter().y();    final double c_r  = circle.getRadius();    final double r_x  = center.x();    final double r_y  = center.y();    if (r_x == c_x && r_y == c_y) {      return timeUntilCircleCollision(circle, ball, velocity);    }    final double r_r2 = (r_x-c_x)*(r_x-c_x) + (r_y-c_y)*(r_y-c_y);    final double r_r  = Math.sqrt(r_r2);    final double phi  = Math.atan2(c_y-r_y, c_x-r_x);    final double b_x  = ball.getCenter().x();    final double b_y  = ball.getCenter().y();    final double b_r  = ball.getRadius();    final double vb_x = velocity.x();    final double vb_y = velocity.y();    final double b_to_c_sq = (b_r + c_r) * (b_r + c_r);    class RotatingCircleDistance implements Newton.Function {      public Newton.Result evaluate(double t) {	double c_t_cos = r_r * Math.cos(omega * t + phi);	double c_t_sin = r_r * Math.sin(omega * t + phi);	double c_x_t = c_t_cos + r_x;	double c_y_t = c_t_sin + r_y;	double b_x_t = vb_x * t + b_x;	double b_y_t = vb_y * t + b_y;	double dist_sq = (c_x_t - b_x_t) * (c_x_t - b_x_t) + (c_y_t - b_y_t) *  (c_y_t - b_y_t);	double f = dist_sq - b_to_c_sq;	double c_x_t_prime = -omega * c_t_sin;	double c_y_t_prime =  omega * c_t_cos;	double f_prime = 2 * (c_x_t - b_x_t) * (c_x_t_prime - vb_x) + 2 * (c_y_t - b_y_t) * (c_y_t_prime - vb_y);	return new Newton.Result(f, f_prime);      }    }    Newton.Function function = new RotatingCircleDistance();    Newton.Result initialDistance = function.evaluate(0);        if (initialDistance.f <= 0) {      if (initialDistance.f_prime >= 0) {	return Double.POSITIVE_INFINITY;      } else {	return 0;      }    }    final double outer_radius = r_r + c_r;    final double inner_radius = (r_r - c_r) >= 0 ? r_r - c_r : 0;    double tempArcWidth = 2 * Math.asin(c_r / r_r);    tempArcWidth = (Double.isNaN(tempArcWidth))?Math.PI:tempArcWidth;    final double arcWidth = tempArcWidth;    IntervalList intervals = new IntervalList(0, maximumForesight);    intervals = restrictSearchInterval(intervals, inner_radius, outer_radius, phi - arcWidth, phi + arcWidth, omega, center, ball, velocity);    return searchForCollision(function, intervals);  }  /**计算小球与旋转的圆形障碍物碰撞后反弹的速度（不考虑摩擦）*/  public Vect reflectRotatingCircle(Circle circle,				    Vect center,				    double angularVelocity,				    Circle ball,				    Vect velocity) {    return reflectRotatingCircle(circle, center,				 angularVelocity,				 ball, velocity,				 1.0);  }    /** 计算小球与旋转的圆形障碍物碰撞反弹后的速度（考虑摩擦）*/  public Vect reflectRotatingCircle(Circle circle,				    Vect center,				    double angularVelocity,				    Circle ball,				    Vect velocity,				    double reflectionCoeff)  {    if (angularVelocity == 0.0) {      return reflectCircle(circle.getCenter(), ball.getCenter(), velocity,			   reflectionCoeff);    }    double radius1 = circle.getRadius();    double radius2 = ball.getRadius();    Vect circleCenter = circle.getCenter().minus(center);    Vect ballCenter = ball.getCenter().minus(center);    double ratio = radius1 / (radius1 + radius2);    Vect diff = circleCenter.minus(ballCenter);    Vect collidePt = circleCenter.plus(diff.times(ratio));    Vect myVel = 	collidePt.times(angularVelocity).rotateBy(Angle.RAD_PI_OVER_TWO);    Vect relativeV = velocity.minus(myVel);    Vect reflectV = reflectCircle(circleCenter, ballCenter, relativeV,				  reflectionCoeff);    Vect absoluteV = myVel.plus(reflectV);    return absoluteV;  }  /****************************************************************************   *   * METHODS FOR MULTI-BALL SIMULATIONS   *   ***************************************************************************/    /**计算两个小球发生碰撞的时间*/  public double timeUntilBallBallCollision(Circle ball1, Vect   vel1, Circle ball2, Vect   vel2) {    Vect pos1 = ball1.getCenter();    Vect pos2 = ball2.getCenter();    double sizes = ball1.getRadius() + ball2.getRadius();    double initPosXDelta = pos1.x() - pos2.x();    double initPosYDelta = pos1.y() - pos2.y();    double velXDelta = vel1.x() - vel2.x();    double velYDelta = vel1.y() - vel2.y();    double sizes2 = sizes * sizes;    double initPosXDelta2 = initPosXDelta * initPosXDelta;    double initPosYDelta2 = initPosYDelta * initPosYDelta;    double initGap2 = initPosXDelta2 + initPosYDelta2 - sizes2;    if (initGap2 <= 0.0) {      Vect velDelta = new Vect(velXDelta, velYDelta);      Vect initPosDelta = new Vect(initPosXDelta, initPosYDelta);       if (velDelta.dot(initPosDelta) < 0.0) {	return 0.0;      } else {	return Double.POSITIVE_INFINITY;      }    }    double a = velXDelta * velXDelta + velYDelta * velYDelta;    double b = 2 * initPosXDelta * velXDelta + 2 * initPosYDelta * velYDelta;    double c = initPosXDelta2 + initPosYDelta2 - sizes2;    double t = minQuadraticSolution(a,b,c);    if (t > 0) {      return t;    } else {      return Double.POSITIVE_INFINITY;    }  }    /** 计算两个小球发生碰撞后的速度*/  public VectPair reflectBalls(Vect center1, double mass1, Vect velocity1, Vect center2, double mass2, Vect velocity2) {    double m1 = mass1;    double m2 = mass2;    double m = m1/m2;    Vect tHat = center1.minus(center2).unitSize();    double vx1 = velocity1.x();    double vx2 = velocity2.x();    double vy1 = velocity1.y();    double vy2 = velocity2.y();    double tx  = tHat.x();    double ty  = tHat.y();    double gamma = (-2 * (vx1*tx*m1 + vy1*ty*m1 - vx2*tx*m*m2 - vy2*ty*m*m2)) /      (tx*tx*m1 + ty*ty*m1 + m*m*tx*tx*m2 + m*m*ty*ty*m2);    return new VectPair(velocity1.plus(tHat.times(gamma)), velocity2.plus(tHat.neg().times(gamma*m)));  }}