package physics;import java.lang.Double; // import statement added to mollify javadocimport java.util.Iterator;import physics.Geometry.VectPair;import physics.Geometry.DoublePair;/**************************************************************************** * Copyright (C) 1999-2001 by the Massachusetts Institute of Technology, *                       Cambridge, Massachusetts. ***************************************************************************//** Geometry单例模式的接口*/public interface GeometryInterface {  public DoublePair quadraticSolution(double a, double b, double c);  public double minQuadraticSolution(double a, double b, double c);  public Vect perpendicularPoint(LineSegment line, Vect point);  public Vect perpendicularPointWholeLine(LineSegment line, Vect point);  public Vect applyReflectionCoeff(Vect incidentVect, Vect reflectedVect, double rCoeff);  public double timeUntilWallCollision(LineSegment line, Circle ball, Vect velocity);  public Vect reflectWall(LineSegment line, Vect velocity, double reflectionCoeff);  public Vect reflectWall(LineSegment line, Vect velocity);  /****************************************************************************   * METHODS FOR CIRCLES   ***************************************************************************/  public double distanceSquared(Vect v1, Vect v2);  public double distanceSquared(double x1, double y1, double x2, double y2);  public double timeUntilCircleCollision(Circle circle, Circle ball, Vect velocity);  public Vect reflectCircle(Vect circle, Vect ball, Vect velocity, double reflectionCoeff);  public Vect reflectCircle(Vect circle, Vect ball, Vect velocity);  /****************************************************************************   * METHODS FOR ROTATING LINE SEGMENTS AND CIRCLES   ***************************************************************************/  public Vect rotateAround(Vect point, Vect cor, Angle a);  public LineSegment rotateAround(LineSegment line, Vect cor, Angle a);  public Circle rotateAround(Circle circle, Vect cor, Angle a);  public DoublePair timeUntilCircleCollision(Circle circle, Vect point, Vect velocity);  public double timeUntilRotatingWallCollision(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity);  public Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity);  public Vect reflectRotatingWall(LineSegment line, Vect center, double angularVelocity, Circle ball, Vect velocity, double reflectionCoeff);  public double timeUntilRotatingCircleCollision(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity);  public Vect reflectRotatingCircle(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity);  public Vect reflectRotatingCircle(Circle circle, Vect center, double angularVelocity, Circle ball, Vect velocity, double reflectionCoeff);  /****************************************************************************   * METHODS FOR MULTI-BALL SIMULATIONS   ***************************************************************************/  public double timeUntilBallBallCollision(Circle ball1, Vect vel1, Circle ball2, Vect vel2);  public VectPair reflectBalls(Vect center1, double mass1, Vect velocity1, Vect center2, double mass2, Vect velocity2);}